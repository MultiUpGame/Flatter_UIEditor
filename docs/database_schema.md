# Схема бази даних для визначень компонентів

Цей документ описує структуру бази даних SQLite, яка служить єдиним джерелом правди для визначення компонентів, їх властивостей та правил генерації коду в екосистемі візуального програмування.

## Таблиця: `components`

Ця таблиця зберігає інформацію про всі типи об'єктів (візуальні, стильові, дані), доступні для різних мов та платформ.

| Назва поля | Тип даних | Опис                                                                 |
| :--------- | :-------- | :------------------------------------------------------------------- |
| `id`       | INTEGER   | PRIMARY KEY                                                          |
| `name`     | TEXT      | Унікальна в межах мови назва компонента (наприклад, "Container", "TextStyle")    |
| `type`     | TEXT      | Категорія компонента: `visual`, `layout`, `style`, `data`            |
| `icon`     | TEXT      | Назва іконки з Material Icons або шлях до файлу для кастомних іконок |
| `language` | TEXT      | Мова або платформа (наприклад, "flutter", "python-tkinter")        |

## Таблиця: `properties`

Ця таблиця описує властивості, які можна редагувати для кожного компонента. Вона підтримує як прості (примітивні) типи, так і складні, вкладені типи через посилання на інші компоненти.

| Назва поля        | Тип даних | Опис                                                                 |
| :---------------- | :-------- | :------------------------------------------------------------------- |
| `id`              | INTEGER   | PRIMARY KEY                                                          |
| `component_id`    | INTEGER   | FOREIGN KEY до `components.id` (компонент-власник цієї властивості)   |
| `name`            | TEXT      | Назва властивості в коді (наприклад, "style", "children")         |
| `display_name`    | TEXT      | Назва для відображення в інспекторі (наприклад, "Стиль тексту")       |
| `property_type`   | TEXT      | Тип властивості: `primitive`, `component_ref`, `list_of_components`   |
| `primitive_type`  | TEXT      | Якщо `property_type` = `primitive`, тут вказується тип: `string`, `color`, `int`, `double`, `bool`, `enum` |
| `component_ref_id`| INTEGER   | FOREIGN KEY до `components.id`. Якщо `property_type` = `component_ref` або `list_of_components`, вказує на тип вкладеного компонента. |
| `default_value`   | TEXT      | Значення за замовчуванням у вигляді рядка                           |
| `options`         | TEXT      | Додаткові опції у форматі JSON (наприклад, для `enum` це буде `["center", "start", "end"]`) |

## Таблиця: `generators`

Ця таблиця містить шаблони для генерації коду для кожного компонента.

| Назва поля     | Тип даних | Опис                                      |
| :------------- | :-------- | :---------------------------------------- |
| `id`           | INTEGER   | PRIMARY KEY                               |
| `component_id` | INTEGER   | FOREIGN KEY до `components.id`            |
| `template`     | TEXT      | Шаблон коду з плейсхолдерами (наприклад, `Container(color: {{color}}, child: {{children}})` ) |

---

## Архітектура Екосистеми та Призначення

Ця база даних є центральним елементом, що зв'язує декілька незалежних інструментів, які працюють разом.

### Головні компоненти архітектури:

1.  **CodeSchema (Редактор Схеми)**
    *   **Що це:** Окремий плагін (або програма) з графічним інтерфейсом.
    *   **Роль:** Його **єдина** задача — надавати зручний UI для управління вмістом цієї бази даних. Саме тут розробник може додавати нові компоненти (`components`), визначати їхні властивості (`properties`) та писати правила генерації коду (`generators`). Це інструмент "архітектора" для розширення можливостей системи.

2.  **Parser & Generator Engines (Рушії Парсингу та Генерації)**
    *   **Що це:** Набір незалежних бібліотек без власного UI.
    *   **Роль:** Це "робочі конячки". Кожен рушій спеціалізується на одній мові (наприклад, існують `DartParserEngine` та `DartGeneratorEngine`).
        *   **Parser** читає вихідний код і, керуючись правилами з БД, перетворює його на універсальне **"Дерево Екземплярів"** (JSON).
        *   **Generator** бере **"Дерево Екземплярів"** і, керуючись шаблонами з БД, генерує чистий вихідний код.

3.  **UIEditor (Візуальний Редактор)**
    *   **Що це:** Плагін, що надає користувачу візуальне полотно, палітру компонентів та інспектор властивостей.
    *   **Роль:** Він є оркестратором. Коли користувач щось робить, `UIEditor` викликає відповідний рушій. Він не містить в собі логіки парсингу чи генерації, а лише делегує цю роботу.

### Як це працює разом?

*   **Візуальне редагування:** Користувач перетягує кнопку в `UIEditor` -> `UIEditor` оновлює "Дерево Екземплярів" -> `UIEditor` викликає `GeneratorEngine` -> `GeneratorEngine` читає дерево та правила з БД -> генерується новий код.

*   **Імпорт коду:** Користувач відкриває файл у `UIEditor` -> `UIEditor` викликає `ParserEngine` -> `ParserEngine` читає код та правила з БД -> створюється "Дерево Екземплярів" -> `UIEditor` відображає його на полотні.

### Ключова перевага

Така розділена архітектура є надзвичайно гнучкою. Щоб додати підтримку нової мови (наприклад, Swift), нам потрібно лише створити нові рушії (`SwiftParser` та `SwiftGenerator`) і додати відповідні правила та компоненти в базу даних за допомогою **CodeSchema**. При цьому `UIEditor` та `CodeSchema` залишаться абсолютно незмінними.