# Flutter UI Редактор

Цей проєкт є візуальним редактором інтерфейсу (UI) для Flutter, створеним за допомогою самого Flutter. Мета — створити інструмент, схожий на редактори в середовищах розробки, який дозволяє візуально конструювати інтерфейс, перетягуючи та налаштовуючи віджети.

## Основні можливості

*   **Візуальне конструювання:** Створення інтерфейсу шляхом перетягування віджетів з палітри на полотно.
*   **Drag-and-Drop:** Інтуїтивне переміщення елементів з палітри та в межах полотна.
*   **Виділення та маніпуляція:** Можливість виділяти віджети на полотні для подальшого редагування.
*   **Модульна архітектура:** Проєкт структуровано для легкого розширення та підтримки.

---

## Архітектура та структура проєкту

Проєкт має чітко розділену структуру, де кожен компонент виконує свою специфічну роль. Це робить систему гнучкою та масштабованою.

### Ключові файли та їх ролі:

*   **`main.dart`**
    *   **Призначення:** Точка входу в додаток.
    *   **Логіка:** Ініціалізує `MaterialApp` та завантажує головний екран редактора — `UiEditorScreen`.

*   **`lib/editor/ui_editor_screen.dart`**
    *   **Призначення:** "Скелет" або головний контейнер усього редактора.
    *   **Логіка:** Визначає загальну структуру інтерфейсу: верхня панель, ліва колонка (палітра, дерево віджетів), центральна область (полотно) та права колонка (інспектор властивостей). Він збирає всі компоненти разом, але не містить складної логіки керування станом.

*   **`lib/editor/widgets_palette_data.dart`**
    *   **Призначення:** Статична "база даних" усіх доступних віджетів.
    *   **Логіка:** Визначає клас `PaletteItem` та містить глобальний список `widgetsPalette`. Кожен `PaletteItem` описує віджет для палітри: його ім'я (`String`), іконку та категорію.

*   **`lib/editor/widget_factory.dart`**
    *   **Призначення:** "Фабрика" для створення віджетів.
    *   **Логіка:** Містить функцію `createWidgetFromName(String name)`. Вона приймає текстову назву віджета (наприклад, "Container") і повертає реальний екземпляр віджета `Widget`. Це центральний механізм, що перетворює дані з палітри на візуальні елементи.

*   **`lib/editor/widgets/canvas_view.dart`**
    *   **Призначення:** "Серце" редактора — інтерактивне полотно.
    *   **Логіка:** Це `StatefulWidget`, який керує списком усіх віджетів, що знаходяться на полотні (`List<CanvasWidgetData>`).
        1.  **Приймання віджетів:** Є `DragTarget`, що "слухає" перетягування `PaletteItem`. При успішному перетягуванні він отримує назву віджета, створює його через `widget_factory` і додає до свого списку стану.
        2.  **Відображення:** Використовує `Stack` для позиціонування віджетів на полотні.
        3.  **Керування станом:** Зберігає позицію, ID та `GlobalKey` кожного віджета. Керує логікою виділення (`_selectedWidgetId`).

*   **`lib/editor/canvas_widget_data.dart`**
    *   **Призначення:** Модель даних для віджета, що вже розміщений на полотні.
    *   **Логіка:** Зберігає унікальний `id`, `position`, `GlobalKey` та сам екземпляр `widget`.

*   **Компоненти палітри та полотна:**
    *   `widgets/palette_category_view.dart`: Відображає одну категорію в палітрі (наприклад, "Макет") у вигляді `ExpansionTile`.
    *   `widgets/palette_item_card.dart`: Картка одного віджета в палітрі. Вона є `Draggable` і несе в собі дані `PaletteItem`.
    *   `widgets/draggable_item.dart`: Обгортка для віджета, що *вже на полотні*. Дозволяє перетягувати його по `Stack` та відображає рамку виділення.

---

### Як "дихає" проєкт: Життєвий цикл віджета

Процес додавання та маніпуляції віджетом чітко показує взаємодію компонентів:

1.  **Ініціалізація:** `UiEditorScreen` читає дані з `widgets_palette_data.dart` і будує з них `PaletteCategoryView`.
2.  **Перетягування з палітри:** Користувач починає тягнути `PaletteItemCard`. В цей момент створюється `Draggable` з даними `PaletteItem`. Як `feedback` (віджет під курсором) використовується реальний віджет, створений через `widget_factory`.
3.  **Падіння на полотно:** `CanvasView` (який є `DragTarget`) приймає `PaletteItem`.
4.  **Створення та реєстрація:**
    *   `CanvasView` викликає `createWidgetFromName()`, передаючи ім'я з отриманого `PaletteItem`.
    *   `widget_factory` повертає новий екземпляр віджета (наприклад, `Container(...)`).
    *   `CanvasView` створює об'єкт `CanvasWidgetData`, загортаючи в нього цей віджет, унікальний ID, позицію курсора та новий `GlobalKey`.
    *   Цей об'єкт додається до списку `_canvasWidgets` всередині `setState`, що ініціює перебудову `CanvasView`.
5.  **Відображення на полотні:** `CanvasView` у методі `build` проходить по списку `_canvasWidgets` і для кожного елемента створює `DraggableItem`.
6.  **Маніпуляція на полотні:**
    *   Сам `DraggableItem` є `Draggable`. Його переміщення оновлює `position` у відповідному `CanvasWidgetData` в стані `CanvasView`.
    *   Клік по `DraggableItem` оновлює `_selectedWidgetId` в стані `CanvasView`, що призводить до появи рамки виділення.

Ця архітектура забезпечує чіткий потік даних (односпрямований) та розділення відповідальності.

---

## Початок роботи (Стандартна інструкція Flutter)

Цей проєкт є стартовою точкою для програми на Flutter.

Декілька ресурсів, які допоможуть вам розпочати, якщо це ваш перший проєкт на Flutter:

-   [Lab: Напишіть свій перший додаток на Flutter](https://docs.flutter.dev/get-started/codelab)
-   [Cookbook: Корисні приклади Flutter](https://docs.flutter.dev/cookbook)

Для отримання допомоги щодо початку роботи з розробкою на Flutter перегляньте
[онлайн-документацію](https://docs.flutter.dev/), яка пропонує навчальні посібники,
приклади, посібник з розробки для мобільних пристроїв та повний довідник API.
